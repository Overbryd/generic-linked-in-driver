{"name":"Generic-linked-in-driver","tagline":"A generic non-blocking linked-in driver for interfacing Erlang and C","body":"# A Generic Linked-in Driver for Erlang\r\n\r\nThis is an attempt to provide a lightweight and clean implementation of a\r\ngeneric [linked-in driver][] for communication between Erlang and C/C++\r\nprograms. It was designed from the ground up to support multi-threaded,\r\nnon-blocking operations, has the ability to hold state across calls and is\r\nentirely customizable. The rationale behind this generic driver is to provide a\r\ndefault and clean implementation for communication between those two\r\nlanguages and to minimize the need to write boilerplate code.\r\n\r\nOf course there is the Generic Erlang Port Driver ([GEPD][]), which lets you\r\ngenerate a driver tailored to your needs by specifying function bindings via C\r\nmacros. However, this generic linked-in driver implementation takes a different\r\napproach and provides the programmer with an easy to use interface without the\r\nneed to generate any code and without any external dependencies. Additionally,\r\nthe name of the driver is set via compiler flag, so that multiple instances of\r\nthe same driver can be compiled and identified by different names without the\r\nneed for code duplication. This is very handy if you design your program to be\r\nconfigured during compilation and need different configurations.\r\n\r\nThere's an example linked-in driver included with the source which demonstrates\r\nthe features of this implementation. You can dive into the code right away or\r\nkeep reading for a detailed reference of features and a simple how-to.\r\n\r\n## Theory of Operation\r\n\r\nThe driver consists of two parts: the Erlang part and the C part. On the Erlang\r\nside the driver is implemented as a generic server. Thus, running a driver\r\nin a supervision hierarchy is simple and also recommended. Every (!) request\r\nto the server can be synchronous (`call`) or asynchronous (`cast`). Naturally,\r\nsynchronous requests wait for the server to respond, and return the result,\r\nwhile asynchronous requests return immediately with `ok`. In the latter case,\r\nany errors on the C side (except the driver crashing due to a segfault or other\r\ncritical error) are not reported. Therefore, asynchronous requests should be\r\nused with caution.\r\n\r\nReceiving the binary sent by the Erlang part, the C driver parses the request,\r\npasses it to a worker thread for non-blocking execution and returns\r\nimmediately. This approach is mandatory, as the main thread on the C side is\r\nexecuted *synchronously*, thus blocking the VM scheduler. Linked-in drivers run\r\nin the same address space as the Erlang virtual machine, so [beware][Warning]:\r\n\r\n> When a driver is loaded it is executed in the context of the emulator, shares\r\n> the same memory and the same thread. This means that all operations in the\r\n> driver must be non-blocking, and that any crash in the driver will bring the\r\n> whole emulator down. In short: you have to be extremely careful!\r\n\r\nThus, before you continue, you should make sure that you have a thorough\r\nunderstanding of the C language, or more precisely of the art of memory\r\nmanagement. You should also know how to use a debugger ([gdb][] is awesome).\r\n\r\nEnough talk, let's play.\r\n\r\n## Installation\r\n\r\nThe generic linked-in driver can be used with plain Erlang or with any OTP\r\napplication. The project itself is compiled using [Rebar][], so in order to\r\nplay with the example driver, just `cd` into the root directory and `make` the\r\nproject. Then go to the `ebin` directory and invoke the `erl` shell:\r\n\r\n``` erlang\r\n{ ok, Pid } = gen_driver_test:start_link(). % => { ok,<0.33.0> }\r\ngen_driver_test:sum(Pid, [1,2,3,4]).        % => { ok, 10.0 }\r\ngen_driver_test:ping(Pid).                  % => ok\r\ngen_driver_test:stats(Pid).                 % => { ok, [{ driver, 2 }, { thread, 2 }] }\r\n```\r\n\r\nThe `stats/1` function returns the number of calls to the driver and the invoked\r\nworker thread. If you start the virtual machine with `erl`, these numbers will\r\nalways be the same. This is because the request is processed synchronously, as\r\nno asynchronous worker threads are present. If you start the virtual machine\r\nwith `erl +A 4`, and thus four worker threads, you will begin to\r\nsee a difference.\r\n\r\nTry it.\r\n\r\nIf you want to use the generic linked-in driver to create your own specific\r\ndriver, you basically have two options: using the linked-in driver as a\r\n**dependency** or as a **copy**.\r\n\r\n### As a dependency via Rebar (recommended)\r\n\r\nUsing Rebar (or another build-tool) is absolutely recommended, as the process\r\nof building a driver is somehow non-trivial. Just open your `rebar.config` and\r\nadd the following lines to your dependencies:\r\n   \r\n``` erlang\r\n{ deps, [\r\n  { gen_driver, \".*\",\r\n    { git, \"git://github.com/squidfunk/generic-linked-in-driver.git\", \"master\" }\r\n  }\r\n}.\r\n```\r\n\r\nAfter fetching your dependencies with `rebar get-deps`, you can start driver\r\ndevelopment. Rebar expects your C source to be located in a directory called\r\n`c_src`. If it isn't there already, create it. Then you just have to create\r\na new file, include the [gen_driver.h][] header file and define the necessary\r\ncallbacks. The header can be included with:\r\n\r\n``` c\r\n#include \"gen_driver.h\"\r\n```\r\n\r\nDuring compilation, the folders containing the header files have to be\r\nincluded with the following flag:\r\n\r\n```\r\n-I deps/gen_driver/c_src\r\n```\r\n\r\nSee the section discussing the build process for more information.\r\n\r\n### As a copy\r\n\r\nIf you don't use a build-tool or want the source to be situated in the same\r\ndirectory as your specific driver, you can just move [gen_driver.c][] and\r\n[gen_driver.h][] to your `c_src` directory, move the Erlang part consisting of\r\n[gen_driver.erl][] to `src`, and get started. Using this approach, including\r\nthe header files and linking them during compilation is easier, as all files\r\nare located in the same directory. However, you will mix up your business logic\r\nand dependencies, which is considered bad practice in general.\r\n\r\n## Usage\r\n\r\n### Erlang\r\n\r\nCreating your own specific linked-in driver using this generic implementation\r\nis quite simple. Take a look at the example driver [gen_driver_test.erl][]. The\r\ndriver is started with:\r\n\r\n``` erlang\r\n{ ok, Pid } = gen_driver:start_link(Path, Name).\r\n```\r\n\r\nA tuple containing the pid is returned, which is the process identifier of the\r\nassociated generic server. Actions can then be called by invoking the\r\ngeneric server functions `call` and `cast`:\r\n\r\n``` erlang\r\ngen_server:call(Pid, { port, Cmd[, Params] }). % => { ok, Response }\r\ngen_server:cast(Pid, { port, Cmd[, Params] }). % => ok\r\n```\r\n\r\nThe `Cmd` parameter must be an integer which is used for identifying the\r\naction to perform on the C side. It is recommended to define those numbers as\r\nmacros in Erlang and C. While parameters are optional, any valid Erlang term\r\ncan be passed.\r\n\r\nIn the case of our example linked-in driver defined in [gen_driver_test.erl][],\r\nthere are two synchronous (`sum/2`, `stats/1`) and one asychronous action\r\n(`ping/1`). Those functions are just simple wrappers which call the respective\r\nC functions:\r\n\r\n``` erlang\r\n% Take an arbitrary mixed list of integers and floats and add all numbers,\r\n% returning the resulting sum.\r\n-spec sum(Pid :: pid(), Numbers :: [float(), ...])\r\n  -> { ok, float() } | { error, atom() }.\r\nsum(Pid, Numbers) ->\r\n  gen_server:call(Pid, { port, ?CMD_SUM, Numbers }).\r\n```\r\n\r\n### C\r\n\r\nGoing to the C side [sic!], six callbacks need to be implemented. A\r\ncallback-based architecture enables the definition of custom initializers on a\r\ndriver- and thread-level. While the driver initializers are executed during the\r\nstart up phase, thread initializers are executed upon the first invocation of a\r\nthread. Taken from [gen_driver.h][], these callbacks are:\r\n\r\n``` c\r\n/**\r\n * Callbacks which manage memory of driver-specific state data.\r\n */\r\nvoid *init();\r\nvoid destroy(void *drv_state);\r\n\r\n/**\r\n * Callbacks which manage memory of thread-specific state data.\r\n */\r\nvoid *thread_init();\r\nvoid thread_destroy(void *trd_state);\r\n\r\n/**\r\n * Callbacks which perform load-balancing and the dispatch of the request.\r\n */\r\nunsigned int *balance(int cmd, unsigned char syn, unsigned int *key);\r\nvoid dispatch(gd_req_t *req, gd_res_t *res, void *drv_state, void *trd_state);\r\n```\r\n\r\nAll callbacks must be defined, even if there's no thread-specific data to hold\r\nor no custom balancing among threads. Thus, a minimal implementation which can\r\nbe used as a skeleton when developing a new driver could be:\r\n\r\n``` c\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n#include <erl_driver.h>\r\n#include <ei.h>\r\n\r\n#include \"gen_driver.h\"\r\n\r\n/**\r\n * Callback to initialize the application-relevant state data when opening the\r\n * port driver and to return a pointer to the newly created driver state.\r\n */\r\nvoid *\r\ninit() {\r\n  return NULL;\r\n}\r\n\r\n/**\r\n * Upon closing the port, this callback is invoked in order to free all memory\r\n * allocated to the driver state.\r\n */\r\nvoid\r\ndestroy(void *drv_state) { }\r\n\r\n/**\r\n * Initialize any thread-specific data. This is called, when first dispatching\r\n * a request to a thread.\r\n */\r\nvoid *\r\nthread_init() {\r\n  return NULL;\r\n}\r\n\r\n/**\r\n * Upon closing the port, this callback is invoked in order to free all memory\r\n * allocated to thread-specific data.\r\n */\r\nvoid\r\nthread_destroy(void *trd_state) { }\r\n\r\n/**\r\n * Load balancing among threads. Balancing is implemented as a modulo\r\n * operation: % THREADS. Return null for round-robin strategy.\r\n */\r\nunsigned int *\r\nbalance(int cmd, unsigned char syn, unsigned int *key) {\r\n  return NULL;\r\n}\r\n\r\n/**\r\n * Dispatch an asynchronous request by invoking the respective callback. If no\r\n * matching command is found, return an error.\r\n */\r\nvoid\r\ndispatch(gd_req_t *req, gd_res_t *res, void *drv_state, void *trd_state) {\r\n  switch (req->cmd) {\r\n\r\n    /* Branch here */\r\n\r\n    default:\r\n      error_set(res, \"command\");\r\n  }\r\n}\r\n```\r\n\r\nNow let's have a look at the dispatch callback which is the entry point for\r\nrequests coming from the Erlang virtual machine. The request as such is\r\ncontained in the first parameter, encoded as a binary, and must be explicitly\r\nparsed using the [Erlang Interface][] functions. This is far from being a\r\ncomplicated task, so for example, parsing a tuple of the form\r\n`{ question, \"Why are we here?\" }` is as simple as:\r\n\r\n``` c\r\nei_decode_tuple_header(req->buf, &req->index, &size);\r\nei_decode_atom(req->buf, &req->index, \"question\");\r\nei_decode_string(req->buf, &req->index, &question);\r\n```\r\n\r\nHowever, we should check for the return values of the Erlang Interface\r\nfunctions, as they return with a status `> 0` when an error occurred. Please\r\nsee `handle_sum/4` in [gen_driver_test.c][] for a more complex example. Then,\r\nafter translating an Erlang term into native C datatypes, and doing our\r\ncalculations, we can take the opposite direction and encode the result using\r\nthe same interface:\r\n\r\n``` c\r\nei_encode_tuple_header(res->buf, &res->index, 2);\r\nei_encode_atom(res->buf, &res->index, \"answer\");\r\nei_encode_string(res->buf, &res->index, \"Plastic!\\0\");\r\n```\r\n\r\nWhile parsing the request involves the first parameter `req`, the result is\r\nencoded into the second parameter `res`. Of course. The result buffer is\r\nallocated 64 bytes, so after writing some bytes one has to check if the\r\nallocated memory is still sufficient with `res->index < 64`. If it isn't, just\r\nre-allocate some more bytes.\r\n\r\nIf an error is encountered during parsing or processing, the helper function\r\n`error_set/2` can be used to exit from a handler. The first parameter has to be the\r\nrespective `res` struct, the second the atom to return, so e.g.:\r\n\r\n``` c\r\nreturn error_set(res, \"badtype\"); // => { error, badtype }\r\n```\r\n\r\nThis translates to the tuple `{ error, badtype }` on the Erlang side. You don't\r\nhave to clean the buffer, just set the error and return. However, when you\r\nreturn, you must make sure that all resources that were allocated are freed.\r\nOtherwise your driver will leak memory, and finally, crash your Erlang\r\napplication.\r\n\r\nAlso remember that asynchronous calls are not able to return anything to the\r\nErlang side. Even if you write something to the result buffer, the contents\r\nare discarded upon termination. This may be desired behaviour, as every\r\nfunction on the C side can be called in both ways. However, it just doesn't\r\nmake any sense when you're fetching entries from a database.\r\n\r\nAnd that is basically it. Now that you learned the basics, you should take a\r\ncloser look at [gen_driver_test.c][], in order to understand the way how the\r\ngeneric driver is used. Interfacing with the generic linked-in driver, the only\r\nthings that need to be done are initializing resources that need to be\r\npersistent across calls and bound to the driver or single threads, decoding the\r\nrequest and encoding the result. Oh, and your custom business logic of course.\r\n\r\nEverything else is already implemented.\r\n\r\n## Building\r\n\r\nNow that we're done implementing our driver, we need to build it. As already\r\nstated, it is absolutely recommended to use [Rebar][] or a similar build-tool\r\nfor this task. Building our newly created linked-in driver, we need to specify\r\nthe driver path (e.g. `priv`) and name (e.g. `test`) which must match the file\r\nname of the resulting binary (`test.so`), and link against the generic driver:\r\n\r\n``` erlang\r\n{ port_specs, [\r\n  { \".*\", \"priv/test.so\", [\r\n    \"deps/gen_driver/c_src/gen_driver.c\", \"c_src/*.c*\"\r\n  ], [\r\n    { env, [\r\n      { \"CFLAGS\", \"$CFLAGS -std=c99 -I deps/gen_driver/c_src -D DRIVER_NAME=test\" }\r\n    ] }\r\n  ] }\r\n] }.\r\n```\r\n\r\nThe generic driver is implemented using the C99 standard, so in case GCC is\r\nused for compilation, the respective flag needs to be set, since GCC defaults to\r\nC89. The path where the generic driver source is located must also be included. As\r\nmentioned before, multiple instances of the same driver with different names and\r\nconfigurations can be compiled without any code duplication.\r\n\r\n## License\r\n\r\nCopyright (c) 2012 Martin Donath\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to\r\ndeal in the Software without restriction, including without limitation the\r\nrights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\nsell copies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\nIN THE SOFTWARE.\r\n\r\n[linked-in driver]: http://www.erlang.org/doc/tutorial/c_portdriver.html\r\n[GEPD]: https://github.com/okeuday/GEPD\r\n[Warning]: http://erlang.org/doc/apps/erts/driver.html#id81992\r\n[gdb]: http://www.gnu.org/software/gdb/\r\n[Rebar]: https://github.com/basho/rebar\r\n[gen_driver.c]: https://github.com/squidfunk/generic-linked-in-driver/blob/master/c_src/gen_driver.c\r\n[gen_driver.h]: https://github.com/squidfunk/generic-linked-in-driver/blob/master/c_src/gen_driver.h\r\n[gen_driver.erl]: https://github.com/squidfunk/generic-linked-in-driver/blob/master/src/gen_driver.erl\r\n[gen_driver_test.c]: https://github.com/squidfunk/generic-linked-in-driver/blob/master/c_src/gen_driver_test.c\r\n[gen_driver_test.erl]: https://github.com/squidfunk/generic-linked-in-driver/blob/master/src/gen_driver_test.erl\r\n[Erlang Interface]: http://erlang.org/doc/man/ei.html","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}